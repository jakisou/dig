<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Dig: PatternSpotter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Dig</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>PatternSpotter Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PatternSpotter" -->
<p>Precomputed sufficient statistics for the DDWSpotter's time series.  
<a href="#_details">More...</a></p>
<div class="dynheader">
Inheritance diagram for PatternSpotter:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classPatternSpotter.png" usemap="#PatternSpotter_map" alt=""/>
  <map id="PatternSpotter_map" name="PatternSpotter_map">
<area href="classPrefixSpotter.html" alt="PrefixSpotter" shape="rect" coords="147,56,284,80"/>
<area href="classWindowSpotter.html" alt="WindowSpotter" shape="rect" coords="588,56,725,80"/>
<area href="classDDWSpotter.html" alt="DDWSpotter" shape="rect" coords="0,112,137,136"/>
<area href="classEuclideanSpotter.html" alt="EuclideanSpotter" shape="rect" coords="147,112,284,136"/>
<area href="classSpringSpotter.html" alt="SpringSpotter" shape="rect" coords="294,112,431,136"/>
<area href="classDtwSearcher.html" alt="DtwSearcher" shape="rect" coords="441,112,578,136"/>
<area href="classEuclideanSearcher.html" alt="EuclideanSearcher" shape="rect" coords="588,112,725,136"/>
<area href="classUSSearcher.html" alt="USSearcher" shape="rect" coords="735,112,872,136"/>
<area href="classSwmSearcher.html" alt="SwmSearcher" shape="rect" coords="661,168,798,192"/>
<area href="classUSEuclideanSearcher.html" alt="USEuclideanSearcher" shape="rect" coords="808,168,945,192"/>
</map>
 </div></div>

<p><a href="classPatternSpotter-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9f0b866f674b49ecd87e480c6499783"></a><!-- doxytag: member="PatternSpotter::PatternSpotter" ref="ad9f0b866f674b49ecd87e480c6499783" args="(Template const &amp;ref, SpotterParams const &amp;p)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PatternSpotter</b> (<a class="el" href="structTemplate.html">Template</a> const &amp;ref, <a class="el" href="structSpotterParams.html">SpotterParams</a> const &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a199895114ec35f78864dc633e043faa4"></a><!-- doxytag: member="PatternSpotter::PatternSpotter" ref="a199895114ec35f78864dc633e043faa4" args="(const PatternSpotter &amp;other)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>PatternSpotter</b> (const <a class="el" href="classPatternSpotter.html">PatternSpotter</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a004aca800eb2abb3c728d85f0ce2a3df"></a><!-- doxytag: member="PatternSpotter::getDistCalls" ref="a004aca800eb2abb3c728d85f0ce2a3df" args="() const " -->
virtual unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>getDistCalls</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab539cbe2923797dde245b511349bf201"></a><!-- doxytag: member="PatternSpotter::getCurrentDist" ref="ab539cbe2923797dde245b511349bf201" args="() const " -->
virtual data_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentDist</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a670ca32fc01f2b1e3f901d9076e22f8c"></a><!-- doxytag: member="PatternSpotter::getCurrentStartTime" ref="a670ca32fc01f2b1e3f901d9076e22f8c" args="() const " -->
virtual tick_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentStartTime</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7dfff2e62e42156afb282c05252d34d5"></a><!-- doxytag: member="PatternSpotter::getCurrentEndTime" ref="a7dfff2e62e42156afb282c05252d34d5" args="() const " -->
virtual tick_t&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentEndTime</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba0e65b4aaf2bdd3ddd5754547f21e9c"></a><!-- doxytag: member="PatternSpotter::getBestCurrentDist" ref="aba0e65b4aaf2bdd3ddd5754547f21e9c" args="() const " -->
virtual data_t&#160;</td><td class="memItemRight" valign="bottom"><b>getBestCurrentDist</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace3f13c9cd0a6aad41a25c167813ad6b"></a><!-- doxytag: member="PatternSpotter::getBestCurrentStartTime" ref="ace3f13c9cd0a6aad41a25c167813ad6b" args="() const " -->
virtual tick_t&#160;</td><td class="memItemRight" valign="bottom"><b>getBestCurrentStartTime</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a568c78a7002e463b125170ea40bd8f86"></a><!-- doxytag: member="PatternSpotter::getBestCurrentEndTime" ref="a568c78a7002e463b125170ea40bd8f86" args="() const " -->
virtual tick_t&#160;</td><td class="memItemRight" valign="bottom"><b>getBestCurrentEndTime</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a4e70fd2f7de2a9fd5ec116f06cb721"></a><!-- doxytag: member="PatternSpotter::getBestCurrentPrefix" ref="a8a4e70fd2f7de2a9fd5ec116f06cb721" args="() const " -->
virtual idx_t&#160;</td><td class="memItemRight" valign="bottom"><b>getBestCurrentPrefix</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22d611c61b5386035d3d59a8b68ff352"></a><!-- doxytag: member="PatternSpotter::setMaxWarp" ref="a22d611c61b5386035d3d59a8b68ff352" args="(steps_t maxWarp)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaxWarp</b> (steps_t maxWarp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b9e0e1ca8ee7abc646dd60650f6ddb5"></a><!-- doxytag: member="PatternSpotter::setScaleFactor" ref="a3b9e0e1ca8ee7abc646dd60650f6ddb5" args="(double r)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setScaleFactor</b> (double r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c512eabc2903be326caf3045100ec38"></a><!-- doxytag: member="PatternSpotter::setMinScaling" ref="a8c512eabc2903be326caf3045100ec38" args="(double r)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setMinScaling</b> (double r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fd0dd3e8d47694631ed303a6efb9f38"></a><!-- doxytag: member="PatternSpotter::setMaxScaling" ref="a9fd0dd3e8d47694631ed303a6efb9f38" args="(double r)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setMaxScaling</b> (double r)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae744821da63e8d40eb542184cb9d4c22"></a><!-- doxytag: member="PatternSpotter::setScalings" ref="ae744821da63e8d40eb542184cb9d4c22" args="(double rMin, double rMax)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setScalings</b> (double rMin, double rMax)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2550dda2c9689ad2121a5d2a9b80327c"></a><!-- doxytag: member="PatternSpotter::setMatchLenRange" ref="a2550dda2c9689ad2121a5d2a9b80327c" args="(length_t minLen, length_t maxLen)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setMatchLenRange</b> (length_t minLen, length_t maxLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad74eff092402e206f9a3572ec959071b"></a><!-- doxytag: member="PatternSpotter::setQueryLenRange" ref="ad74eff092402e206f9a3572ec959071b" args="(length_t minLen, length_t maxLen)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setQueryLenRange</b> (length_t minLen, length_t maxLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9d80a2844a3d112e626585e65746ef4"></a><!-- doxytag: member="PatternSpotter::setUseScalingEnvelopes" ref="aa9d80a2844a3d112e626585e65746ef4" args="(bool useEnvelopes)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setUseScalingEnvelopes</b> (bool useEnvelopes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#ae90b0fdd6a1e6de0b87a2766cebbf446">updateMatrix</a> (const tick_t t, const data_t *sample, data_t cutoff)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Top-level function to be called at each time step that updates the current distance (and any other state) when a new sample is received.  <a href="#ae90b0fdd6a1e6de0b87a2766cebbf446"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#ae7debde9435183ce72ab8f5878303c37">sequenceLocallyOptimal</a> (<a class="el" href="classSubsequence.html">Subsequence</a> seq) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the supplied sequence is guaranteed to be optimal, or whether this <a class="el" href="classPatternSpotter.html" title="Precomputed sufficient statistics for the DDWSpotter&#39;s time series.">PatternSpotter</a> might be able to discover a better (conflicting) one.  <a href="#ae7debde9435183ce72ab8f5878303c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#ae0d3eb1c2568bb82ddecb51884b8343d">purgeAllOverlap</a> (<a class="el" href="classSubsequence.html">Subsequence</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify this PatternSpotter's state so that it doesn't report any subsequences that overlap with the sequence provided.  <a href="#ae0d3eb1c2568bb82ddecb51884b8343d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a5f1a91e024f5928a5eff7c6c9bd2be42">purgeInferiorOverlap</a> (<a class="el" href="classSubsequence.html">Subsequence</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify this PatternSpotter's state so that it doesn't report any subsequences that overlap with the sequence provided and have a higher distance to this PatternSpotter's time series.  <a href="#a5f1a91e024f5928a5eff7c6c9bd2be42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6123a855833c6c5b7a5b1a130fb9d541"></a><!-- doxytag: member="PatternSpotter::getClassLabel" ref="a6123a855833c6c5b7a5b1a130fb9d541" args="() const " -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a6123a855833c6c5b7a5b1a130fb9d541">getClassLabel</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class of the training time series for this <a class="el" href="classPatternSpotter.html" title="Precomputed sufficient statistics for the DDWSpotter&#39;s time series.">PatternSpotter</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a737a42c486bc1eed9d3a3f970493645b"></a><!-- doxytag: member="PatternSpotter::getLength" ref="a737a42c486bc1eed9d3a3f970493645b" args="() const " -->
idx_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a737a42c486bc1eed9d3a3f970493645b">getLength</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the training time series for this <a class="el" href="classPatternSpotter.html" title="Precomputed sufficient statistics for the DDWSpotter&#39;s time series.">PatternSpotter</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a7902f9377af43062615bd76a39ce2663">setSameClassMeansOptimal</a> (bool meansOptimal)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether matches of the same class can "conflict" for purposes of determining whether a sequence is locally optimal.  <a href="#a7902f9377af43062615bd76a39ce2663"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a122dfb8ac4331e5a297bb0ef713f3d98"></a><!-- doxytag: member="PatternSpotter::setBestSubSequence" ref="a122dfb8ac4331e5a297bb0ef713f3d98" args="(Subsequence seq)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a122dfb8ac4331e5a297bb0ef713f3d98">setBestSubSequence</a> (<a class="el" href="classSubsequence.html">Subsequence</a> seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subsequence to beat. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a191ddf0c695e1d5858f5a7e16bbad6e4"></a><!-- doxytag: member="PatternSpotter::setReportCriteria" ref="a191ddf0c695e1d5858f5a7e16bbad6e4" args="(ReportCriteria criteria)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a191ddf0c695e1d5858f5a7e16bbad6e4">setReportCriteria</a> (ReportCriteria criteria)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the criteria used to determine whether subsequences are optimal (and thus should be reported) <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ccd6af38cbdff00cbd5fdb62cf65b15"></a><!-- doxytag: member="PatternSpotter::normalize" ref="a2ccd6af38cbdff00cbd5fdb62cf65b15" args="(data_t dist) const " -->
virtual data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a2ccd6af38cbdff00cbd5fdb62cf65b15">normalize</a> (data_t dist) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts distances calculated internally to the normalized distances used to compare different PatternMonitors' results. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f418ea9ec8f5d07967ce4504fb9a341"></a><!-- doxytag: member="PatternSpotter::denormalize" ref="a3f418ea9ec8f5d07967ce4504fb9a341" args="(data_t dist) const " -->
virtual data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a3f418ea9ec8f5d07967ce4504fb9a341">denormalize</a> (data_t dist) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the normalized distances used to compare pattern monitors to a non-normalized distance that we use internally. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a620c65d3d9a83e8e5a4d1f540c743aff"></a><!-- doxytag: member="PatternSpotter::mTime" ref="a620c65d3d9a83e8e5a4d1f540c743aff" args="" -->
tick_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a620c65d3d9a83e8e5a4d1f540c743aff">mTime</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The current time step. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2db6824124fb862d731d6c6b65e5100"></a><!-- doxytag: member="PatternSpotter::mLabel" ref="ab2db6824124fb862d731d6c6b65e5100" args="" -->
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>mLabel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa483b4fae8e86d5379e654e5b3d54062"></a><!-- doxytag: member="PatternSpotter::refData" ref="aa483b4fae8e86d5379e654e5b3d54062" args="" -->
data_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#aa483b4fae8e86d5379e654e5b3d54062">refData</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The time series itself. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc0241e89c7e25c734c0a9a3c30a3b71"></a><!-- doxytag: member="PatternSpotter::M" ref="acc0241e89c7e25c734c0a9a3c30a3b71" args="" -->
idx_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#acc0241e89c7e25c734c0a9a3c30a3b71">M</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of the time series. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5e20aecd375374e03691d7afd603049"></a><!-- doxytag: member="PatternSpotter::dMin" ref="ad5e20aecd375374e03691d7afd603049" args="" -->
data_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#ad5e20aecd375374e03691d7afd603049">dMin</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The current distance to beat (used as a cutoff) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bcb1975c681f8f1070ea5f41543a428"></a><!-- doxytag: member="PatternSpotter::ts" ref="a1bcb1975c681f8f1070ea5f41543a428" args="" -->
tick_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a1bcb1975c681f8f1070ea5f41543a428">ts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The start time of the subsequence to beat. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4297ffdb55b65b3f941973b44ad5ee39"></a><!-- doxytag: member="PatternSpotter::te" ref="a4297ffdb55b65b3f941973b44ad5ee39" args="" -->
tick_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a4297ffdb55b65b3f941973b44ad5ee39">te</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The end time of the subsequence to beat. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c9b6ee82e4aaff0ba146ff2043825d1"></a><!-- doxytag: member="PatternSpotter::mDistCalls" ref="a9c9b6ee82e4aaff0ba146ff2043825d1" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#a9c9b6ee82e4aaff0ba146ff2043825d1">mDistCalls</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">how many times this monitor has called the distance function (used) only for profiling) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad51c46571a956ce15bd45705b84998e2"></a><!-- doxytag: member="PatternSpotter::mSameClassMeansOptimal" ref="ad51c46571a956ce15bd45705b84998e2" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#ad51c46571a956ce15bd45705b84998e2">mSameClassMeansOptimal</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">whether matches of the same class automatically count as optimal <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6dfde1d0da8bd0979f61fc0c7b36d20"></a><!-- doxytag: member="PatternSpotter::mReportCriteria" ref="ac6dfde1d0da8bd0979f61fc0c7b36d20" args="" -->
ReportCriteria&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPatternSpotter.html#ac6dfde1d0da8bd0979f61fc0c7b36d20">mReportCriteria</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">enum defining criteria for reporting a match <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Precomputed sufficient statistics for the DDWSpotter's time series. </p>
<p>Dynamic Data Warping distance </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae0d3eb1c2568bb82ddecb51884b8343d"></a><!-- doxytag: member="PatternSpotter::purgeAllOverlap" ref="ae0d3eb1c2568bb82ddecb51884b8343d" args="(Subsequence seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PatternSpotter::purgeAllOverlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubsequence.html">Subsequence</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify this PatternSpotter's state so that it doesn't report any subsequences that overlap with the sequence provided. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The subsequence with which there should be no overlap; note that the end time of the subsequence must be less than or equal to the current time for this function to work correctly. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classPrefixSpotter.html#a5bad99025905b1a9c55c3980e554e06f">PrefixSpotter</a>, and <a class="el" href="classWindowSpotter.html#a6fdb934bc5e5b7dfa89b9ed808fdc2bc">WindowSpotter</a>.</p>

</div>
</div>
<a class="anchor" id="a5f1a91e024f5928a5eff7c6c9bd2be42"></a><!-- doxytag: member="PatternSpotter::purgeInferiorOverlap" ref="a5f1a91e024f5928a5eff7c6c9bd2be42" args="(Subsequence seq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PatternSpotter::purgeInferiorOverlap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubsequence.html">Subsequence</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modify this PatternSpotter's state so that it doesn't report any subsequences that overlap with the sequence provided and have a higher distance to this PatternSpotter's time series. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The subsequence with which there should be no overlap; note that the end time of the subsequence must be less than or equal to the current time for this function to work correctly. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classPrefixSpotter.html#a16a45f3fbf08d27bc4d130cdb0ae7d79">PrefixSpotter</a>, and <a class="el" href="classWindowSpotter.html#afaddb5309699f18154ce094bddceebcb">WindowSpotter</a>.</p>

<p>Referenced by <a class="el" href="classPatternSpotter.html#a122dfb8ac4331e5a297bb0ef713f3d98">setBestSubSequence()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7debde9435183ce72ab8f5878303c37"></a><!-- doxytag: member="PatternSpotter::sequenceLocallyOptimal" ref="ae7debde9435183ce72ab8f5878303c37" args="(Subsequence seq) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool PatternSpotter::sequenceLocallyOptimal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubsequence.html">Subsequence</a>&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the supplied sequence is guaranteed to be optimal, or whether this <a class="el" href="classPatternSpotter.html" title="Precomputed sufficient statistics for the DDWSpotter&#39;s time series.">PatternSpotter</a> might be able to discover a better (conflicting) one. </p>
<p>Note that what's "optimal" depends on this PatternSpotter's reportCriteria and whether subsequences of the same class are automatically considered optimal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>The subsequence to be evaluated for optimality </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classPrefixSpotter.html#a6d59666de293bb4b83d808b806372c72">PrefixSpotter</a>, and <a class="el" href="classWindowSpotter.html#a8627c799baff0fdd5fef87d3e849d8b2">WindowSpotter</a>.</p>

</div>
</div>
<a class="anchor" id="a7902f9377af43062615bd76a39ce2663"></a><!-- doxytag: member="PatternSpotter::setSameClassMeansOptimal" ref="a7902f9377af43062615bd76a39ce2663" args="(bool meansOptimal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PatternSpotter::setSameClassMeansOptimal </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>meansOptimal</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set whether matches of the same class can "conflict" for purposes of determining whether a sequence is locally optimal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">meansOptimal</td><td>If true, subsequences are optimal if there is no better match except in the same class; if false, subsequences are optimal if there is no better match in any class </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classPrefixSpotter.html#a0468fa2e376fd555f8170552e3e461ad">PrefixSpotter</a>.</p>

<p>References <a class="el" href="classPatternSpotter.html#ad51c46571a956ce15bd45705b84998e2">mSameClassMeansOptimal</a>.</p>

<p>Referenced by <a class="el" href="classSignalMonitor.html#a550eff594be24b345c4de26f8c945890">SignalMonitor::addTemplate()</a>.</p>

</div>
</div>
<a class="anchor" id="ae90b0fdd6a1e6de0b87a2766cebbf446"></a><!-- doxytag: member="PatternSpotter::updateMatrix" ref="ae90b0fdd6a1e6de0b87a2766cebbf446" args="(const tick_t t, const data_t *sample, data_t cutoff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void PatternSpotter::updateMatrix </td>
          <td>(</td>
          <td class="paramtype">const tick_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const data_t *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_t&#160;</td>
          <td class="paramname"><em>cutoff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Top-level function to be called at each time step that updates the current distance (and any other state) when a new sample is received. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The current time </td></tr>
    <tr><td class="paramname">sample</td><td><a class="el" href="classA.html" title="a subsequence of a time series">A</a> pointer to the latest data point in this signal </td></tr>
    <tr><td class="paramname">cutoff</td><td>The distance above which distance calculations should be abandoned </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classDDWSpotter.html#a0ecc631bbfd0acc0cfe4cfb5130712a2">DDWSpotter</a>, <a class="el" href="classEuclideanSpotter.html#aeba40de55c0caf6da620947c8bb86aee">EuclideanSpotter</a>, <a class="el" href="classPrefixSpotter.html#a4da9d5eac4719567ab8c7bbd2fa8a872">PrefixSpotter</a>, <a class="el" href="classSpringSpotter.html#a9bd1af1dec85ee32f60159a2d9b6c41a">SpringSpotter</a>, and <a class="el" href="classWindowSpotter.html#a9983bac7d06149efc6c3dedc5417b34d">WindowSpotter</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/stream/<a class="el" href="PatternSpotter_8hpp_source.html">PatternSpotter.hpp</a></li>
<li>src/stream/PatternSpotter.cpp</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Jul 27 2014 00:40:33 for Dig by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
